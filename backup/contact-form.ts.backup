import { Component, inject, output } from '@angular/core';
import { ContactService } from '../../services/contact.service';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';

@Component({
  selector: 'app-contact-form',
  imports: [ReactiveFormsModule],
  templateUrl: './contact-form.html',
  styleUrl: './contact-form.css'
})
export class ContactForm {
  private fb = inject(FormBuilder);
  private api = inject(ContactService);

  sending = false;
  sent = false;
  error?: string;
  errorMessage = () => this.error;
  
  // Output per comunicare con il componente padre
  errorChange = output<{message: string, type: 'error' | 'warning' | 'info' | 'success', fieldId?: string, removeId?: string} | undefined>();
  successChange = output<string | undefined>();

  form = this.fb.group({
    name: ['', [Validators.required, Validators.minLength(2)]],
    surname: ['', [Validators.required, Validators.minLength(2)]],
    email: ['', [Validators.required, Validators.email]],
    subject: [''],
    message: ['', [Validators.required, Validators.minLength(10)]],
    consent: [false, [Validators.requiredTrue]],
    website: ['']
  });

  constructor() {
    // Validazione in tempo reale per ogni campo - solo per aggiornare lo stato interno
    this.form.get('name')?.valueChanges.subscribe(() => this.validateField('name'));
    this.form.get('surname')?.valueChanges.subscribe(() => this.validateField('surname'));
    this.form.get('email')?.valueChanges.subscribe(() => this.validateField('email'));
    this.form.get('message')?.valueChanges.subscribe(() => this.validateField('message'));
    this.form.get('consent')?.valueChanges.subscribe(() => this.validateField('consent'));
  }

  submit() {
    this.error = undefined;
    this.errorChange.emit(undefined);
    if (this.form.invalid) {
      this.form.markAllAsTouched();
      this.showValidationError();
      return;
    }
    // honeypot: se è stato riempito, non inviare
    if (this.form.value.website) {
      this.sent = true;
      this.form.reset({ consent: false, website: '' });
      return;
    }

    this.sending = true;
    this.api.send(this.form.value as any).subscribe({
      next: () => {
        this.sent = true;
        this.sending = false;
        this.form.reset({ consent: false, website: '' });
        
        // Emetti evento di successo
        this.successChange.emit('Messaggio inviato con successo!');
      },
      error: (err) => {
        console.error('[contact] error', err);
        const errorMessage = err?.error?.message ?? 'Invio non riuscito. Riprova.';
        this.error = errorMessage;
        this.errorChange.emit({ message: errorMessage, type: 'error' });
        this.sending = false;
      }
    });
  }

  showValidationError() {
    const errors = this.getValidationErrors();
    this.error = errors.join(', ');
    
    // Emetti ogni singolo errore come notifica separata con tipo appropriato
    errors.forEach(error => {
      const errorType = this.getErrorType(error);
      this.errorChange.emit({ message: error, type: errorType });
    });
  }

  getValidationErrors(): string[] {
    const errors: string[] = [];
    
    if (this.form.get('name')?.invalid) {
      errors.push('Inserisci un nome valido (min 2 caratteri)');
    }
    if (this.form.get('surname')?.invalid) {
      errors.push('Inserisci un cognome valido (min 2 caratteri)');
    }
    if (this.form.get('email')?.invalid) {
      errors.push('Inserisci una email valida');
    }
    if (this.form.get('message')?.invalid) {
      errors.push('Il messaggio deve contenere almeno 10 caratteri');
    }
    if (this.form.get('consent')?.invalid) {
      errors.push('Devi acconsentire al trattamento dei dati');
    }
    
    return errors;
  }

  getErrorType(errorMessage: string): 'error' | 'warning' | 'info' | 'success' {
    // Determina il tipo di notifica in base al messaggio
    if (errorMessage.includes('email')) {
      return 'error'; // Errori di email sono critici
    }
    if (errorMessage.includes('consentire')) {
      return 'warning'; // Consenso è un avviso importante
    }
    if (errorMessage.includes('caratteri')) {
      return 'info'; // Lunghezza minima è informativo
    }
    if (errorMessage.includes('valido')) {
      return 'warning'; // Validazione è un avviso
    }
    
    return 'error'; // Default per errori generici
  }

  clearError() {
    this.error = undefined;
    this.errorChange.emit(undefined);
  }

  validateField(fieldName: string) {
    const field = this.form.get(fieldName);
    if (field && field.touched && field.invalid) {
      this.showFieldError(fieldName);
    } else if (field && field.valid) {
      // Se il campo è valido, rimuovi eventuali notifiche per questo campo
      this.removeFieldNotification(fieldName);
      this.checkForOtherErrors();
    }
  }

  showFieldError(fieldName: string) {
    const field = this.form.get(fieldName);
    if (!field || !field.invalid) return;

    let errorMessage = '';
    
    if (fieldName === 'name') {
      if (field.hasError('required')) {
        errorMessage = 'Inserisci un nome valido (min 2 caratteri)';
      } else if (field.hasError('minlength')) {
        errorMessage = 'Inserisci un nome valido (min 2 caratteri)';
      }
    } else if (fieldName === 'surname') {
      if (field.hasError('required')) {
        errorMessage = 'Inserisci un cognome valido (min 2 caratteri)';
      } else if (field.hasError('minlength')) {
        errorMessage = 'Inserisci un cognome valido (min 2 caratteri)';
      }
    } else if (fieldName === 'email') {
      if (field.hasError('required')) {
        errorMessage = 'Inserisci una email valida';
      } else if (field.hasError('email')) {
        errorMessage = 'Inserisci una email valida';
      }
    } else if (fieldName === 'message') {
      if (field.hasError('required')) {
        errorMessage = 'Il messaggio è obbligatorio';
      } else if (field.hasError('minlength')) {
        errorMessage = 'Il messaggio deve contenere almeno 10 caratteri';
      }
    } else if (fieldName === 'consent') {
      if (field.hasError('required')) {
        errorMessage = 'Devi acconsentire al trattamento dei dati';
      }
    }

    // Emetti notifica solo se c'è un errore
    if (errorMessage) {
      this.error = errorMessage;
      const errorType = this.getErrorType(errorMessage);
      this.errorChange.emit({ 
        message: errorMessage, 
        type: errorType,
        fieldId: fieldName 
      });
    }
  }

  checkForOtherErrors() {
    // Se tutti i campi sono validi, rimuovi l'errore
    if (this.form.valid) {
      this.error = undefined;
      this.errorChange.emit(undefined);
    }
  }

  onFieldBlur(fieldName: string) {
    const field = this.form.get(fieldName);
    if (field) {
      field.markAsTouched();
      // Mostra solo l'errore del campo specifico quando l'utente esce
      this.showFieldError(fieldName);
    }
  }

  showAllValidationErrors() {
    // Se il form è valido, non mostrare errori
    if (this.form.valid) {
      this.checkForOtherErrors();
      return;
    }

    // Mostra tutti gli errori di validazione come notifiche separate
    const errors = this.getValidationErrors();
    errors.forEach(error => {
      const errorType = this.getErrorType(error);
      this.errorChange.emit({ message: error, type: errorType });
    });
  }

  removeFieldNotification(fieldName: string) {
    // Crea un ID univoco per la notifica di questo campo
    const fieldNotificationId = `form-field-${fieldName}`;
    
    // Emetti un evento per rimuovere la notifica specifica di questo campo
    // Il componente padre dovrà gestire la rimozione basandosi su questo ID
    this.errorChange.emit({ 
      message: '', 
      type: 'success', 
      removeId: fieldNotificationId 
    } as any);
  }
}